
# Домашнее задание к занятию «Микросервисы: масштабирование»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: Кластеризация

Предложите решение для обеспечения развёртывания, запуска и управления приложениями.
Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.

Решение должно соответствовать следующим требованиям:
- поддержка контейнеров;
- обеспечивать обнаружение сервисов и маршрутизацию запросов;
- обеспечивать возможность горизонтального масштабирования;
- обеспечивать возможность автоматического масштабирования;
- обеспечивать явное разделение ресурсов, доступных извне и внутри системы;
- обеспечивать возможность конфигурировать приложения с помощью переменных среды, в том числе с возможностью безопасного хранения чувствительных данных таких как пароли, ключи доступа, ключи шифрования и т. п.

Обоснуйте свой выбор.

## Решение 1

Для решения требований по развертыванию, запуску и управлению приложениями, я предлагаю использовать сочетание Kubernetes, Helm, и HashiCorp Vault. Это решение обеспечивает гибкость, автоматизацию и безопасность, требуемые для работы современных распределенных систем на основе контейнеров.

1. Kubernetes (K8s) – оркестрация контейнеров
Kubernetes предоставляет все необходимые механизмы для управления контейнерами, таких как:

- Поддержка контейнеров: Kubernetes управляет контейнерами через поды, которые могут состоять из одного или нескольких контейнеров.

- Обнаружение сервисов и маршрутизация: В Kubernetes встроена служба DNS, которая позволяет автоматически обнаруживать сервисы. Для маршрутизации запросов используется объект Ingress, позволяющий управлять доступом к сервисам извне.

- Горизонтальное масштабирование: Kubernetes поддерживает горизонтальное масштабирование через механизм Horizontal Pod Autoscaler, который масштабирует количество подов на основе метрик, таких как использование CPU или пользовательские метрики.

- Автоматическое масштабирование: Kubernetes позволяет автоматически изменять количество подов в зависимости от нагрузки с помощью HPA (Horizontal Pod Autoscaler) и Cluster Autoscaler для динамического изменения числа узлов в кластере.

- Разделение ресурсов: Kubernetes поддерживает сеть namespaces, которая позволяет изолировать ресурсы и разделить доступы между внешними и внутренними компонентами.

- Конфигурирование с использованием переменных среды: Конфигурация приложений через переменные окружения поддерживается в Kubernetes с помощью объектов ConfigMap и Secret. Это позволяет безопасно хранить и управлять конфиденциальными данными.

2. Helm – управление манифестами и шаблонизацией

Helm является менеджером пакетов для Kubernetes, который:

- Обеспечивает возможность удобного и повторяемого развертывания приложений.

- Позволяет параметризовать конфигурацию приложений через использование Helm-чартов, где можно легко задавать переменные, включая чувствительные данные.

- Упрощает обновление, управление версиями и откаты приложений, развернутых в кластере.

3. HashiCorp Vault – безопасное хранение конфиденциальных данных

Vault обеспечивает безопасное хранение и управление чувствительными данными, такими как пароли, ключи доступа и ключи шифрования:

- Интеграция с Kubernetes: Vault может быть интегрирован с Kubernetes через механизм K8s Secrets и обеспечивать динамическое управление ключами доступа, шифрованием данных и конфиденциальными переменными среды.

- Управление доступом: Vault может настраивать политики доступа для приложений, предоставляя им временные и безопасные учетные данные.

Пример взаимодействия компонентов:
1. Развертывание:

- Вы создаете чарт Helm для своего приложения, где описываете контейнеры, сетевые настройки, ресурсы и конфигурацию переменных окружения.

- Чарт Helm разворачивается в Kubernetes-кластере, используя kubectl и параметры, переданные через Helm.

2. Обнаружение и маршрутизация:

- Kubernetes автоматически создает DNS-имена для сервисов. Внешний доступ обеспечивается через Ingress или LoadBalancer.
Масштабирование:

Kubernetes автоматически масштабирует ваши приложения с помощью HPA на основе метрик, собранных системой мониторинга (например, Prometheus).

3. Безопасное хранение секретов:

- Vault хранит конфиденциальные данные и через встроенные механизмы интеграции передает их в Kubernetes как секреты, доступные приложениям через переменные окружения или файлы.

**Обоснование выбора:**

- Kubernetes является стандартом для оркестрации контейнеров и обладает всеми необходимыми возможностями для обеспечения обнаружения сервисов, автоматического масштабирования и управления сетевыми ресурсами.

- Helm упрощает управление развертыванием и обновлением приложений в Kubernetes, предоставляя гибкость через шаблонизацию.

- Vault обеспечивает безопасность чувствительных данных, их управление и интеграцию с Kubernetes, что позволяет эффективно работать с конфиденциальной информацией, необходимой для настройки приложений.

Альтернативным вариантом Kubernetes может являться OpenShift, который в свою очередь основан на Kubernetes, а значит к нему также подходят все требования к системе на основе микросервисной архитектуры. Но OpenShift имеет ограничения в бесплатной версии, что может привести к необходимости покупки корпоративной версии. Также OpenShift меньше аудитория и может быть меньше справочных материалов

## Задача 2: Распределённый кеш * (необязательная)

Разработчикам вашей компании понадобился распределённый кеш для организации хранения временной информации по сессиям пользователей.
Вам необходимо построить Redis Cluster, состоящий из трёх шард с тремя репликами.

### Схема:

![11-04-01](https://user-images.githubusercontent.com/1122523/114282923-9b16f900-9a4f-11eb-80aa-61ed09725760.png)

---

## Решение 2

 Конфигурационный файл для мастер редиса (Одинаковый на всех машинах):
   ```
   port 7000
   dir /var/lib/redis/7000/
   appendonly yes
   protected-mode no
   cluster-enabled yes
   cluster-node-timeout 5000
   cluster-config-file /etc/redis/cluster/7000/nodes_7000.conf
   pidfile /var/run/redis_7000.pid
   ```

   Конфигурационный файл для слейв редиса (Одинаковый на всех машинах):
   ```
   port 7001
   dir /var/lib/redis/7001
   appendonly yes
   protected-mode no
   cluster-enabled yes
   cluster-node-timeout 5000
   cluster-config-file /etc/redis/cluster/7001/nodes_7001.conf
   pidfile /var/run/redis_7001.pid
   ```

   Файл сервиса для мастер редиса (Одинаковый на всех машинах):
   ```
   [Unit]
   Description=Redis cluster for netology
   After=network.target
   
   [Service]
   ExecStart=/usr/bin/redis-server /etc/redis/cluster/7000/redis_7000.conf --supervised systemd
   ExecStop=/bin/redis-cli -h 127.0.0.1 -p 7000 shutdown
   Type=notify
   User=root
   Group=root
   RuntimeDirectory=redis
   RuntimeDirectoryMode=0755
   LimitNOFILE=65535
   
   [Install]
   WantedBy=multi-user.target
   ```

   Файл сервиса для слейв редиса (Одинаковый на всех машинах):
   ```
   [Unit]
   Description=Redis cluster for netology
   After=network.target
   
   [Service]
   ExecStart=/usr/bin/redis-server /etc/redis/cluster/7001/redis_7001.conf --supervised systemd
   ExecStop=/bin/redis-cli -h 127.0.0.1 -p 7001 shutdown
   Type=notify
   User=root
   Group=root
   RuntimeDirectory=/etc/redis/cluster/7001
   RuntimeDirectoryMode=0755
   LimitNOFILE=65535
   
   [Install]
   WantedBy=multi-user.target
   ```

   Инициализация кластера redis:  
  
  <img width="740" alt="Init Redis cluster" src="https://github.com/user-attachments/assets/05dbef7b-997c-49bb-aa12-8a55b327c225">
  

   Информация по запущенным сервисам редиса:

  <img width="733" alt="running services" src="https://github.com/user-attachments/assets/3be14c6a-d923-44b5-9da5-281d3957753a">

